\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{geometry}
\geometry{margin=1in}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{minted}        % for code highlighting (requires -shell-escape)
\usepackage{titlesec}
\usepackage{fancyhdr}
\usepackage{caption}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{float}

\lstset{
  basicstyle=\ttfamily\small,
  breaklines=true,
  backgroundcolor=\color{gray!10},
  frame=single,
}
\lstdefinelanguage{yaml}{
  keywords={true,false,null,y,n},
  keywordstyle=\color{blue},
  basicstyle=\ttfamily\small,
  sensitive=false,
  comment=[l]{\#},
  morecomment=[l]{\#},
  commentstyle=\color{gray}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

% Header and footer
\pagestyle{fancy}
\fancyhf{}
\rhead{Project Documentation}
\lhead{Rocket App}
\rfoot{\thepage}

% Section format
\titleformat{\section}{\normalfont\Large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalfont\large\bfseries}{\thesubsection}{1em}{}

% Title page
\title{
    \vspace{4cm}
    \Huge\textbf{Rocket App} \\
    \LARGE\textit{Pervasive Computing} \\
    \vspace{2cm}
    \large Author: \\
    \large Date: \today \\
    \vfill
}
\date{}
\author{}

\begin{document}

\maketitle
\newpage
\tableofcontents
\newpage

\section{Einleitung}
Im Rahmen des Moduls Ubiquitous Computing von Professor Knauth sollten die
Studierenden das Erlernte in einem praktischen Projekt anwenden.
Das Projekt beschäftigt sich mit der Thematik des Ubiquitous Computings. Die
Durchdringung von Alltagsgegenständen mit Informationstechnologie und die
Vernetzung von smarten Systemen führen zu einer Umwelt, in der in allen Bereichen
Veränderungen auftreten. Wir haben uns dabei für eine Mobile App für Smartphones entschieden.

\subsection{Projektbeschreibung}
Die \textbf{Rocket App} ist eine mobile Anwendung, die es Nutzerinnen und Nutzern ermöglicht, ihre täglichen Schritte automatisch zu erfassen. Die App belohnt Aktivität durch ein Punktesystem, das sowohl auf der Anzahl der Schritte als auch auf der Teilnahme an Herausforderungen (Challenges) basiert. Zusätzlich können Läufe (Runs) aufgezeichnet, auf Karten dargestellt und im Nachhinein analysiert werden. Die Kombination aus Bewegungstracking, Gamification und sozialem Vergleich macht die Rocket App zu einem motivierenden Begleiter im Alltag.

\subsection{Ziele und Motivation}
Ziel der Rocket App ist es, Nutzerinnen und Nutzer zu einem aktiveren Lebensstil zu motivieren. Durch spielerische Elemente wie Punkte, Ranglisten und Challenges soll Bewegung im Alltag gefördert und langfristig zur Gewohnheit gemacht werden. Gerade im Kontext zunehmender Digitalisierung und Bewegungsmangel bietet die App eine niedrigschwellige Möglichkeit, körperliche Aktivität zu fördern und messbar zu machen.

Die Zielgruppe der App sind Menschen, die ihre Bewegung im Alltag tracken und sich selbst oder im Wettbewerb mit anderen motivieren möchten. Dazu gehören sowohl Gelegenheitsnutzer als auch sportlich Aktive.

\section{Entwicklung}
\subsection{Versionsveraltung}
Für die Entwicklung der \textbf{Rocket App} wurde ein zentrales Git-Repository unter GitHub verwendet. Im Zuge dessen haben wir eine eigene Organisation namens \texttt{RealTeamRocket} auf GitHub gegründet, um die Projektressourcen zentral zu verwalten und die Zusammenarbeit im Team zu erleichtern. Das Repository ist unter folgendem Link öffentlich einsehbar:
\url{https://github.com/RealTeamRocket/rocket-app}

Das Repository enthält sämtliche Quellcodes des Projekts – darunter das Flutter-Frontend der App, das Backend sowie eine begleitende Website. Durch diese zentrale Struktur wird sichergestellt, dass alle Komponenten konsistent versioniert und gepflegt werden können.

Zur effizienten Zusammenarbeit im Team wurde mit einem \textbf{Branching-Modell} gearbeitet. Dabei existieren Hauptzweige wie \texttt{main} und \texttt{dev}, während neue Features oder Bugfixes in separaten Feature-Branches entwickelt und anschließend via Pull Request integriert wurden. Dieses Vorgehen erlaubt paralleles Arbeiten, minimiert Merge-Konflikte und sorgt für eine saubere Trennung zwischen stabilen Releases und laufender Entwicklung.

Zur Sprint-Planung und Aufgabenverteilung kommt zusätzlich ein \textbf{GitHub Project Board} zum Einsatz, das als Kanban-Board konfiguriert wurde. Dort werden Tickets angelegt, priorisiert und den jeweiligen Teammitgliedern zugewiesen. Das Board dient als zentrale Planungsgrundlage für unsere zweiwöchigen Sprints und bietet eine transparente Übersicht über den Fortschritt einzelner Aufgaben und Meilensteine.

Durch die Kombination aus GitHub, strukturiertem Branch-Workflow und projektbezogener Aufgabenplanung konnte eine effektive und nachvollziehbare Versionskontrolle realisiert werden, die sowohl technische als auch organisatorische Anforderungen erfüllt.

\subsection{Entwicklungsumgebungen}

Für die Entwicklung der \textbf{Rocket App} kamen unterschiedliche Entwicklungsumgebungen zum Einsatz, abgestimmt auf die jeweiligen Anforderungen der Frontend- und Backend-Komponenten.

Die App wurde mit dem Framework \textbf{Flutter} entwickelt. Für die mobile Entwicklung wurde hauptsächlich \textbf{Android Studio} verwendet, insbesondere für das Erstellen, Debuggen und Testen auf realen Geräten sowie Emulatoren. Ergänzend kam auch der integrierte \textbf{Emulator von Visual Studio Code (VS Code)} zum Einsatz, insbesondere für schnelle Tests und kleinere Anpassungen während der Entwicklung. Dank der Flutter-Integration in beide Umgebungen konnten Entwickler flexibel je nach Präferenz arbeiten.

Für das \textbf{Backend}, das in der Programmiersprache \textbf{Go} entwickelt wurde, war die Wahl der Entwicklungsumgebung weitgehend frei. Da Go standardmäßig nur über den Go Language Server Protocol (gopls) unterstützt wird, kamen primär Editoren mit entsprechender LSP-Unterstützung zum Einsatz. Die bevorzugten Tools waren hier \textbf{Visual Studio Code} sowie der moderne Editor \textbf{Zed}, welcher sich durch seine Performance und klare Nutzeroberfläche auszeichnet. Beide Umgebungen bieten durch die LSP-Anbindung komfortable Features wie Autovervollständigung, Syntaxhervorhebung und Code-Navigation.

Durch diese vielseitige Toolauswahl konnten alle Projektbeteiligten in einer für sie optimalen Umgebung arbeiten, ohne auf zentrale Entwicklungsfeatures verzichten zu müssen. Dies förderte eine produktive Arbeitsweise und erhöhte die Effizienz im Entwicklungsalltag.

\subsection{Virtual Private Server}

Für das Hosting der Server-Komponenten der \textbf{Rocket App} wird ein \textbf{Virtual Private Server (VPS)} von \textbf{Oracle Cloud} genutzt. Auf diesem Server laufen sowohl das \textbf{Backend} als auch die dazugehörige \textbf{PostgreSQL-Datenbank}. Um die Dienste zuverlässig und portabel zu betreiben, werden beide Komponenten in separaten \textbf{Docker-Containern} ausgeführt.

Die Orchestrierung dieser Container erfolgt über eine \textbf{Docker Compose}-Konfiguration, die das Starten, Stoppen und Verwalten der Services vereinfacht. Zusätzlich kommt das Tool \textbf{Watchtower} zum Einsatz, das regelmäßig nach aktualisierten Docker-Images prüft. Sobald ein neues Image – beispielsweise des Backends – auf \textbf{Docker Hub} verfügbar ist, lädt Watchtower es automatisch herunter und startet den entsprechenden Container neu. Dadurch wird sichergestellt, dass der Server stets mit der aktuellsten Version läuft, ohne manuelles Eingreifen.

\subsection{Deployment}

Das Deployment des Backends ist vollständig automatisiert und in den Entwicklungsworkflow über \textbf{GitHub-Actions} integriert. Bei jedem \textbf{Pull Request auf den \texttt{master}-Branch}, der Änderungen im Verzeichnis \texttt{rocket-backend} betrifft, wird eine entsprechende GitHub-Action ausgelöst.

Diese Action übernimmt das Erstellen eines neuen Docker-Images auf Basis des aktuellen Codes und lädt es anschließend in ein zentrales \textbf{Docker Hub}-Repository hoch. Sobald das neue Image dort verfügbar ist, erkennt \textbf{Watchtower} auf dem Oracle-Server das Update und sorgt automatisch für einen nahtlosen Rollout der neuen Backend-Version.

Ein Ausschnitt aus dem verwendeten Deployment-Workflow sieht wie folgt aus:

\begin{lstlisting}[language=yaml, caption={GitHub Action zur automatisierten Bereitstellung}, label={lst:deployment}]
name: Build and Push Docker Image

on:
  push:
    branches:
      - master
    paths:
      - 'rocket-backend/**'

jobs:
  build-and-push:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PAT }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v4
        with:
          context: ./rocket-backend
          push: true
          tags: ${{ secrets.DOCKER_USERNAME }}/rocket-backend:latest
\end{lstlisting}

Durch diese Pipeline wird das Deployment effizient, reproduzierbar und sicher gestaltet – ein entscheidender Vorteil bei der iterativen Weiterentwicklung der Rocket App.


\subsection*{Architektur (HTTPS mit VPS)}

Die Abbildung \ref{fig:https-architektur} zeigt die Systemarchitektur im produktiven Einsatz, wie sie auf einem Virtual Private Server (VPS) umgesetzt ist. Die Architektur wurde so entworfen, dass sie sicher, skalierbar und wartbar ist. Sie umfasst mehrere Technologien und Container, die gezielt für ihre jeweiligen Stärken eingesetzt werden.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth]{images/HttpsArchitektur.png}
    \caption{Produktivarchitektur mit Docker, Nginx und HTTPS}
    \label{fig:https-architektur}
\end{figure}

\paragraph{Flutter Mobile App}
Die \textbf{Rocket App}, entwickelt mit dem Flutter Framework, läuft auf iOS und Android. Sie dient als Hauptschnittstelle für die Nutzer. Flutter wurde gewählt, weil es eine performante, plattformübergreifende Entwicklung mit einer Codebasis ermöglicht und gleichzeitig native App-Erlebnisse bietet.

Die App sendet ihre Daten  über REST-API-Aufrufe direkt an den VPS. Dabei handelt es sich um typische Aktionen wie das Hochladen von Läufen, Synchronisieren von Schritten, Highscorelisten oder das Abrufen von Challenges.

\paragraph{VPS und Containerisierung}
Der gesamte produktive Stack läuft auf einem \textbf{VPS (Virtual Private Server)}. Dies bietet volle Kontrolle über die Serverumgebung bei gleichzeitig moderaten Kosten.

Im VPS sind alle Backend-Komponenten mithilfe von \textbf{Docker} containerisiert. Docker erlaubt es, die Applikation isoliert, portabel und versionssicher zu betreiben. Dies erleichtert auch das Deployment (z.\,B. durch GitHub Actions) sowie die Wartung im laufenden Betrieb.

\paragraph{Nginx als Reverse Proxy}
Als erste Instanz innerhalb des VPS fungiert \textbf{Nginx}. Dieser Reverse Proxy nimmt eingehende HTTP(S)-Anfragen entgegen, kümmert sich um SSL/TLS-Verschlüsselung (z.\,B. mit Let's Encrypt) und leitet die Anfragen an den Go-Backend-Container weiter.

Die Verwendung von Nginx bringt mehrere Vorteile:
\begin{itemize}
    \item Trennung von HTTPS-Terminierung und Backend-Logik
    \item Unterstützung von statischen Dateien und Caching
    \item Flexible Weiterleitung und Lastverteilung
\end{itemize}

\paragraph{Go Backend}
Das \textbf{Go-Backend} ist der Kern der Serverlogik. Es verarbeitet alle Anfragen der Mobile App über REST-Schnittstellen. Go wurde gewählt wegen seiner hervorragenden Performance, statischen Typisierung, geringen Laufzeitanforderungen und der guten Eignung für API-Services.

Typische Funktionen des Go-Backends sind:
\begin{itemize}
    \item Verarbeiten und Speichern von Läufen, Schritten, Chats
    \item Authentifizierung und Benutzerverwaltung
    \item Bereitstellen von Geo- und Statistikdaten
\end{itemize}

\paragraph{PostgreSQL Datenbank}
Alle persistenten Daten werden in einer \textbf{PostgreSQL-Datenbank} gespeichert. PostgreSQL wurde aufgrund seiner Zuverlässigkeit, SQL-Kompatibilität und Unterstützung von Geodaten (PostGIS) ausgewählt. Es läuft ebenfalls als Docker-Container innerhalb des VPS-Netzwerks.

\paragraph{Weitere Komponenten (kurz)}
Die \textbf{Vue.js-Webseite}, ebenfalls im Bild dargestellt, kommuniziert wie die App mit dem Backend. Zusätzlich nutzt sie WebSockets für Live-Interaktionen. Eine externe Schnittstelle – hier die \textbf{OpenTopoData API} – wird vom Backend genutzt, um Höhendaten für Strecken zu ermitteln.

\paragraph{Zusammenfassung der Architekturvorteile}
\begin{itemize}
    \item \textbf{Flutter:} Plattformübergreifende Entwicklung mit nativem Look \& Feel
    \item \textbf{Go:} Hochperformant, ideal für APIs
    \item \textbf{Docker:} Portabilität, einfache Updates und Isolierung
    \item \textbf{Nginx:} Reverse Proxy für Sicherheit und Routing
    \item \textbf{PostgreSQL:} Robuste, erweiterbare SQL-Datenbank mit Geo-Support
\end{itemize}

\section{Lokale Entwicklung}
\label{sec:lokale-entwicklung}

\subsection*{Unterschied zur Produktionsumgebung}

Die lokale Entwicklungsumgebung ist eine vereinfachte Version der Produktivarchitektur. Ziel ist es, einzelne Komponenten unabhängig testen und entwickeln zu können, ohne direkt ein Deployment auf dem VPS durchführen zu müssen.

Im Gegensatz zur vollständigen Produktionsarchitektur (siehe Abbildung \ref{fig:https-architektur}), bei der mehrere Docker-Container über einen Nginx-Reverse-Proxy orchestriert werden, wird in der lokalen Umgebung lediglich das Backend mit der zugehörigen Datenbank als \textbf{lokaler Docker-Container} betrieben.

\subsection*{Architektur der lokalen Umgebung}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{images/Architecture.png}
    \caption{Lokale Entwicklungsumgebung}
    \label{fig:local-architektur}
\end{figure}

\paragraph{Backend \& Datenbank}
Das Go-Backend wird lokal in einem Docker-Container gestartet, ebenso wie eine PostgreSQL-Datenbank mit PostGIS-Erweiterung. Dadurch wird eine konsistente Entwicklungsumgebung geschaffen, die der produktiven Struktur sehr nahekommt, jedoch ohne HTTPS-Absicherung oder externe Abhängigkeiten wie Nginx.

\paragraph{Mobile App (Flutter)}
Die Mobile App kann über USB oder WLAN direkt auf einem realen Gerät installiert werden. Die Verwendung eines echten Geräts ist zwingend notwendig, da die App auf Geo-Koordinaten (GPS) und Schrittzählerdaten zugreift, welche über Gerätesensoren bereitgestellt werden. Emulatoren liefern keine oder nur ungenaue Sensorwerte und sind daher für Entwicklung und Tests ungeeignet.

\paragraph{Web-Frontend (Vue.js + Vite)}
Das Web-Frontend basiert auf Vue.js und kann ohne Docker lokal gestartet werden. Dazu wird der \textbf{Vite Development Server} verwendet. Dieser bietet schnelles Hot Reloading und ist leichtgewichtig. Eine wichtige Besonderheit ist die Verwendung eines \textbf{Proxy-Setups}, das API-Anfragen aus dem Browser zur lokal laufenden Go-API weiterleitet. Dadurch können Frontend und Backend unabhängig voneinander entwickelt werden, ohne auf ein Deployment angewiesen zu sein.

\subsection*{Backend Testing}

Für das Go-Backend existiert eine umfassende Teststrategie, die auf \textbf{Integrationstests} basiert. Ziel ist es, nicht nur die einzelnen Funktionen isoliert zu testen, sondern auch das Zusammenspiel zwischen REST-Endpunkten und Datenbankabfragen realistisch zu überprüfen.

\paragraph{Verwendete Tools}
Zum Schreiben und Ausführen der Tests kommen zwei populäre Go-Testbibliotheken zum Einsatz:
\begin{itemize}
    \item \texttt{github.com/onsi/ginkgo/v2} – Framework für Behavior-Driven Development (BDD)
    \item \texttt{github.com/onsi/gomega} – Assertion-Bibliothek für lesbare und präzise Testausdrücke
\end{itemize}

\paragraph{Isolierte Testumgebung mit Testcontainers}
Zur Laufzeit der Tests wird mit Hilfe von \texttt{testcontainers-go} eine isolierte Datenbankinstanz in einem temporären Docker-Container gestartet. Diese Testdatenbank wird automatisch erstellt, mit den notwendigen Migrationsskripten versehen und nach jedem Testlauf vollständig bereinigt.

Dadurch ist sichergestellt, dass:
\begin{itemize}
    \item Jeder Test in einer identischen, kontrollierten Umgebung läuft
    \item Seiteneffekte zwischen Tests ausgeschlossen sind
    \item Produktivdaten niemals verwendet oder überschrieben werden
\end{itemize}

\paragraph{Testabdeckung}
Getestet werden:
\begin{itemize}
    \item Alle REST-Endpunkte des Backends
    \item Validierung und Fehlerfälle
    \item Alle relevanten Datenbankoperationen (CRUD)
\end{itemize}

Diese Teststrategie ermöglicht es, Änderungen im Backend schnell und sicher zu überprüfen, ohne dass manuelles Testen notwendig ist. Sie dient auch als wichtige Grundlage für zukünftige CI/CD-Pipelines.

\paragraph{Automatisierte Testausführung bei Pull Requests}
Alle Tests werden automatisch ausgeführt, sobald ein Pull Request (PR) auf den \texttt{master}-Branch erstellt wird. Dies erfolgt über eine GitHub Action, die das Test-Backend in einer isolierten Umgebung ausführt. Ein PR kann nur gemerged werden, wenn alle Tests erfolgreich durchlaufen. Dies garantiert, dass:
\begin{itemize}
    \item keine fehlerhaften Änderungen in die Hauptentwicklungslinie gelangen,
    \item alle Funktionen weiterhin wie erwartet funktionieren,
    \item die Softwarequalität über alle Sprints hinweg erhalten bleibt.
\end{itemize}

\section{Setup und Lokale Ausführung}

Um das System lokal vollständig auszuführen, werden folgende Tools benötigt:

\begin{itemize}
    \item \textbf{Flutter} -- zum Kompilieren und Starten der mobilen Anwendung
    \item \textbf{Docker \& Docker Compose} -- für das Starten des Backends und der PostgreSQL-Datenbank
\end{itemize}

\subsection*{1. Backend und Datenbank starten}

Zunächst muss das Backend gemeinsam mit der Datenbank gestartet werden. Dazu navigiert man ins Verzeichnis \texttt{rocket-backend} und führt dort den folgenden Befehl aus:

\begin{verbatim}
docker-compose up --build
\end{verbatim}

Dieser Befehl setzt voraus, dass im selben Verzeichnis eine \texttt{.env}-Datei vorhanden ist. Diese Datei enthält alle Konfigurationsvariablen für Backend und Datenbank. Ein Beispiel-Template sieht wie folgt aus:

\begin{verbatim}
PORT=8080
APP_ENV=local
BLUEPRINT_DB_HOST=postgres
BLUEPRINT_DB_PORT=5432
BLUEPRINT_DB_DATABASE=blueprint
BLUEPRINT_DB_USERNAME=melkey
BLUEPRINT_DB_PASSWORD=password1234
BLUEPRINT_DB_SCHEMA=public

# generated with openssl rand -base64 64
JWT_SECRET=
API_KEY=

PGADMIN_DEFAULT_EMAIL=admin@admin.com
PGADMIN_DEFAULT_PASSWORD=admin
\end{verbatim}

Nach dem Start des Containers wird die Datenbank automatisch durch ein spezielles Migration-Image \texttt{migrate/migrate} mit den benötigten Tabellen und Constraints versorgt.

\subsection*{2. Lokale Kommunikation mit dem Handy aktivieren}

Damit die mobile App während der lokalen Entwicklung mit dem Backend kommunizieren kann, ist es entscheidend, dass das Handy im selben Netzwerk wie der Entwicklungsrechner ist. Zudem muss entweder:

\begin{itemize}
    \item die lokale Firewall deaktiviert oder entsprechend konfiguriert werden,
    \item oder eine Regel erstellt werden, die eingehenden Traffic auf den Port \texttt{8080} (bzw. den in der \texttt{.env} definierten Port) erlaubt.
\end{itemize}

\subsection*{3. Mobile App konfigurieren und starten}

In der mobilen Anwendung (Verzeichnis \texttt{mobile\_app}) muss ebenfalls eine \texttt{.env}-Datei angelegt werden. Diese enthält die IP-Adresse des Rechners, auf dem das Backend läuft. Die Datei besteht aus nur einer Zeile:

\begin{verbatim}
BACKEND_URL=http://<IP_DEINES_RECHNERS>:8080
\end{verbatim}

Diese IP-Adresse kann je nach System mit dem Befehl \texttt{ip a} (Linux) oder \texttt{ipconfig} (Windows) ermittelt werden. Diese Angabe ist essenziell, da die mobile App sonst nicht weiß, wohin HTTP-Anfragen gesendet werden sollen. In der Produktionsumgebung ist diese Variable fest definiert, bei der lokalen Entwicklung muss sie jedoch manuell angepasst werden.

\subsection*{Hinweis zur mobilen Ausführung}

Die App sollte idealerweise auf einem physischen Smartphone installiert und ausgeführt werden. Grund hierfür ist, dass für einige Kernfunktionen (z.\,B. Geodaten, Schrittzählerdaten) reale Sensorsignale erforderlich sind, welche von Emulatoren in der Regel nicht bereitgestellt werden.

\section{ER-Modell und Datenbankarchitektur}

Die Anwendung verwendet \textbf{PostgreSQL} als relationale Datenbank, ergänzt durch zwei wichtige Erweiterungen:

\begin{itemize}
    \item \textbf{PostGIS}: Ermöglicht die Speicherung und Verarbeitung von Geodaten, insbesondere Routeninformationen als \texttt{LINESTRING}. Diese werden für Laufstrecken und geplante Routen benötigt.
    \item \textbf{pgcrypto}: Wird zur Generierung von \texttt{UUIDs} (Universally Unique Identifiers) genutzt, die als Primärschlüssel in fast allen Tabellen verwendet werden.
\end{itemize}

Die Entscheidung für UUIDs anstelle klassischer Integer-IDs beruht auf mehreren Vorteilen:
\begin{itemize}
    \item \textbf{Sicherheit}: UUIDs sind schwer zu erraten und dadurch weniger anfällig für gezielte Angriffe über ID-Inkremente.
    \item \textbf{Skalierbarkeit}: Sie ermöglichen das Erstellen von IDs über verschiedene Systeme hinweg, ohne Kollisionen befürchten zu müssen.
    \item \textbf{Unabhängigkeit von Kontexten}: Da UUIDs global eindeutig sind, kann etwa eine Laufstrecke unabhängig vom Nutzer eindeutig referenziert werden.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{images/RocketERLight.png}
    \caption{ER-Modell der Rocket-Anwendung}
\end{figure}

\subsection*{Tabellenübersicht}

\begin{itemize}
    \item \textbf{users} – Zentrale Entität für Nutzer:innen der App. Enthält Username, Email und den Punktestand (Rocketpoints).
    \item \textbf{credentials} – Separat gespeicherte Zugangsdaten (E-Mail, Passwort) zur besseren Trennung von Authentifizierungs- und Nutzungsdaten.
    \item \textbf{planned\_runs} – Beinhaltet vom Nutzer vorgeplante Routen (mit Geometrie), Name und Ziel-Distanz. Essentiell für die Trainingsplanung.
    \item \textbf{runs} – Tatsächlich durchgeführte Läufe, ebenfalls mit Geodaten, Distanz und Dauer. Grundlage für Fortschrittsverfolgung.
    \item \textbf{daily\_steps} – Aggregierte tägliche Schrittzahlen pro Nutzer, oft durch Sensorschnittstellen (z.\,B. Mobilgerät) geliefert.
    \item \textbf{activities} – Logbuch-Funktion für allgemeine Nutzeraktionen. Enthält Textnachrichten und Zeitstempel.
    \item \textbf{friends} – Bidirektionale Freundschaften zwischen Nutzer:innen. Erlaubt soziales Tracking und Interaktion.
    \item \textbf{challenges} – Vorgedefinierte Herausforderungen mit Beschreibung und Punktebelohnung.
    \item \textbf{user\_challenges} – Relationstabelle zwischen Nutzer:innen und Herausforderungen, inkl. Statusinformationen wie \texttt{is\_completed}.
    \item \textbf{settings} – Benutzerbezogene Konfigurationen, insbesondere Zielwerte wie Schrittanzahl oder Profilbild.
    \item \textbf{image\_store} – Speicherung binärer Bilddaten (z.\,B. Avatare, Challenge-Bilder). Gekoppelt an andere Tabellen über \texttt{image\_id}.
    \item \textbf{chat\_messages} – Ermöglicht einfache Nachrichten zwischen Nutzer:innen. Repräsentiert den sozialen Aspekt der App.
    \item \textbf{chat\_messages\_reactions} – Erweiterung für Reaktionen (z.\,B. Emojis) auf Chatnachrichten. Enthält Zeitstempel und Verweis auf Nutzer:in.
\end{itemize}

Alle Relationen sind über \texttt{uuid}-Fremdschlüssel miteinander verknüpft, was eine klare logische Trennung und Erweiterbarkeit des Systems unterstützt. Die Kombination aus Geodaten, sozialen Funktionen und gamifizierter Nutzerinteraktion bildet das Rückgrat der Applikation.



\section{Handy App}
\begin{enumerate}
    \item unterschiedlichen pages
    \item funktionsweisen
\end{enumerate}



\end{document}

